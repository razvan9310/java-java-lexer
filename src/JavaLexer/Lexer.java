package JavaLexer;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * Lexer based on a {@link LexerAutomaton}. Runs on binary files, given as {@code byte} arrays.
 */
public class Lexer {
  /**
   * Default automaton start state.
   */
  private static int START_STATE = 0;

  /**
   * Current cursor position in the input file.
   */
  private int mCurrentPosition = 0;
  /**
   * Current automaton state.
   */
  private Integer mCurrentState = START_STATE;
  /**
   * Automaton to run.
   */
  private LexerAutomaton mLexerAutomaton;
  /**
   * Binary input file to run on.
   */
  private byte[] mInput;
  /**
   * List of identified token values, as {@code String}s.
   */
  private ArrayList<String> mTokenValues;
  /**
   * Mapping of tokens, given by their position in {@link #mTokenValues}, to the {@code ArrayList}
   * of positions they appeared at in the source file.
   */
  private HashMap<Integer, ArrayList<Integer>> mTokenPositionsMap;

  /**
   * Returns an identified token's {@code String} value.
   * @param index Position in {@link #mTokenValues}.
   * @return Token's {@code String} value, e.g. "public", "true", "{" etc.
   */
  public String getTokenValue(int index) {
    if (index < 0 || index >= mTokenValues.size()) {
      return null;
    }
    return mTokenValues.get(index);
  }

  /**
   * Returns the {@link Lexer}'s current cursor position in the source file.
   */
  public int getCurrentPosition() {
    return mCurrentPosition;
  }

  /**
   * Provides the {@link Lexer} with a {@link LexerAutomaton} to work with.
   * @param lexerAutomaton Automaton generated by the {@link LexerAutomatonFactory}.
   */
  public void setLexerAutomaton(LexerAutomaton lexerAutomaton) {
    mLexerAutomaton = lexerAutomaton;
    mCurrentState = START_STATE;
    mTokenValues = new ArrayList<String>();
    mTokenPositionsMap = new HashMap<Integer, ArrayList<Integer>>();
  }

  /**
   * Provides the {@link Lexer} with a binary array to run on.
   * @param input {@code byte} array containing source file data.
   */
  public void setInput(byte[] input) {
    mInput = input;
    mCurrentPosition = 0;
  }

  /**
   * Returns the next valid {@link Token}, or null if no valid {@link Token} was found. The current
   * position cursor will be advanced to the byte after the end of the given {@link Token}.
   */
  public Token getToken() {
    String tokenValue = "";
    int offset = 0;
    int lastFinalOffset = 0;
    Integer lastFinalState = null;
    String lastFinalTokenValue = "";
    char currentCharacter;

    while (mCurrentPosition + offset < mInput.length && (mCurrentState = mLexerAutomaton.transition(
            mCurrentState, currentCharacter = ((char) (mInput[mCurrentPosition + offset] & 0xFF))))
            != null) {
      tokenValue += currentCharacter;
      if (mLexerAutomaton.tokenTypeForFinalState(mCurrentState) != null) {
        if (mCurrentState == START_STATE) {
          tokenValue = "";
        }
        lastFinalOffset = offset + 1;
        lastFinalState = mCurrentState;
        lastFinalTokenValue = tokenValue;
      }
      ++offset;
    }

    if (lastFinalState == null) {
      return null;
    } else {
      mCurrentState = START_STATE;
      if (!mTokenValues.contains(lastFinalTokenValue)) {
        mTokenValues.add(lastFinalTokenValue);
      }
      int positionInTokensList = mTokenValues.indexOf(lastFinalTokenValue);
      ArrayList tokenPositions = mTokenPositionsMap.get(positionInTokensList);
      if (tokenPositions == null) {
        tokenPositions = new ArrayList<Integer>();
      }
      tokenPositions.add(mCurrentPosition);
      mTokenPositionsMap.put(positionInTokensList, tokenPositions);

      mCurrentPosition += lastFinalOffset;

      return new Token(mLexerAutomaton.tokenTypeForFinalState(lastFinalState), positionInTokensList);
    }
  }

  /**
   * Returns a {@code String[]} containing a description of the {@link Token}s table, one
   * {@code String} per token. The Strings are formatted as:
   * Token no: %d | value: %s | positions: %d %d ...
   */
  public String[] getFormattedTableDescription() {
    ArrayList<String> tableDescription = new ArrayList<String>();
    for (int i = 0; i < mTokenValues.size(); ++i) {
      String row = String.format("Token no: %d | value: %s | positions:", i, mTokenValues.get(i));
      ArrayList<Integer> positions = mTokenPositionsMap.get(i);
      for (Integer position : positions) {
        row += " " + String.valueOf(position);
      }
      tableDescription.add(row);
    }
    return tableDescription.toArray(new String[tableDescription.size()]);
  }
}
